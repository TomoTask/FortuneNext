// ═══════════════════════════════════════════════════════════════
//  出資管理システム v1.0 - Google Apps Script Backend
//  ★ このファイルを Apps Script エディタに貼り付けてデプロイ
// ═══════════════════════════════════════════════════════════════

// ─── 設定 ───────────────────────────────────────────────────
const SPREADSHEET_ID = '1qu_ee_zMrvWTdDh7v09cTbwTsD_8vTHWW4EfuM6HKVo';

const SH = {
  config:       'config',
  users:        'users',
  products:     'products',
  groups:       'groups',
  group_prices: 'group_prices',
  orders:       'orders',
  returns:      'returns',
  threads:      'threads',
  messages:     'messages',
  sessions:     'sessions',
  schedule:     'schedule',
};

const SESSION_TTL_HOURS = 24;
const PAYMENT_DEADLINE_DAYS = 2;

// ═══════════════════════════════════════════════════════════════
//  エントリーポイント
// ═══════════════════════════════════════════════════════════════

function doGet(e)  { return _handle(e); }
function doPost(e) { return _handle(e); }

function _handle(e) {
  try {
    const params = _parseParams(e);
    const action = params.action || '';

    // ── ログイン（トークン不要） ──
    if (action === 'login') return _json(doLogin(params));

    // ── 認証チェック ──
    const session = validateSession(params.token);
    if (!session) return _json({ success: false, error: 'ログインが必要です', code: 'AUTH_REQUIRED' });

    const { userId, role, groupId } = session;

    // ── ルーティング ──
    let result;
    switch (action) {
      // 認証
      case 'logout':           result = doLogout(params.token); break;
      case 'me':               result = getMe(userId); break;
      case 'updateProfile':    result = updateProfile(params, userId); break;

      // 商品
      case 'getProducts':      result = getProducts(role, groupId); break;
      case 'getProduct':       result = getProduct(params.productId, role, groupId); break;
      case 'createProduct':    result = requireRole('admin', role) || createProduct(params); break;
      case 'updateProduct':    result = requireRole('admin', role) || updateProduct(params); break;

      // グループ価格
      case 'getGroupPrices':   result = getGroupPrices(params.productId, role, groupId); break;
      case 'updateGroupPrice': result = requireRole(['admin','leader'], role) || updateGroupPrice(params, role, groupId); break;

      // 注文
      case 'getOrders':        result = getOrders(role, userId, groupId); break;
      case 'createOrder':      result = requireRole('user', role) || createOrder(params, userId, groupId); break;
      case 'updateOrder':      result = requireRole(['admin','leader'], role) || updateOrder(params); break;

      // お戻し
      case 'getReturns':       result = getReturns(role, userId, groupId); break;
      case 'createReturn':     result = requireRole('user', role) || createReturn(params, userId); break;
      case 'updateReturn':     result = requireRole(['admin','leader'], role) || updateReturn(params, userId); break;

      // メッセージ
      case 'getThreads':       result = getThreads(role, userId, groupId); break;
      case 'getMessages':      result = getMessages(params.threadId, userId); break;
      case 'sendMessage':      result = sendMessage(params, userId, role); break;

      // 管理
      case 'getDashboard':     result = requireRole('admin', role) || getDashboard(); break;
      case 'getUsers':         result = getUsers(role, groupId); break;
      case 'getGroups':        result = getGroups(); break;
      case 'getSchedule':      result = getSchedule(); break;
      case 'updateSchedule':   result = requireRole('admin', role) || updateSchedule(params); break;

      // ユーザー管理
      case 'createUser':       result = requireRole('admin', role) || createUser(params); break;
      case 'updateUser':       result = requireRole('admin', role) || updateUser(params); break;
      case 'resetPassword':    result = requireRole('admin', role) || resetPassword(params); break;
      case 'deleteUser':       result = requireRole('admin', role) || deleteUser(params); break;

      // ファイルアップロード
      case 'uploadReceipt':    result = uploadReceipt(params, userId); break;

      default: result = { success: false, error: 'Unknown action: ' + action };
    }
    return _json(result);
  } catch (err) {
    Logger.log('ERROR: ' + err.message + '\n' + err.stack);
    return _json({ success: false, error: 'サーバーエラーが発生しました', detail: err.message });
  }
}

// ═══════════════════════════════════════════════════════════════
//  ユーティリティ
// ═══════════════════════════════════════════════════════════════

function _parseParams(e) {
  const params = { ...(e.parameter || {}) };
  if (e.postData) {
    try { Object.assign(params, JSON.parse(e.postData.contents)); } catch (_) {}
  }
  return params;
}

function _json(data) {
  return ContentService.createTextOutput(JSON.stringify(data)).setMimeType(ContentService.MimeType.JSON);
}

function _ss() {
  return SpreadsheetApp.openById(SPREADSHEET_ID);
}

function _sheet(name) {
  return _ss().getSheetByName(name);
}

/** シートの全データをオブジェクト配列で返す */
function _readAll(sheetName) {
  const sheet = _sheet(sheetName);
  if (!sheet) return [];
  const data = sheet.getDataRange().getValues();
  if (data.length < 2) return [];
  const headers = data[0].map(h => String(h).trim());
  return data.slice(1).filter(row => row[0] !== '').map(row => {
    const obj = {};
    headers.forEach((h, i) => { obj[h] = row[i]; });
    return obj;
  });
}

/** シートに1行追加 */
function _appendRow(sheetName, obj) {
  const sheet = _sheet(sheetName);
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(h => String(h).trim());
  const row = headers.map(h => obj[h] !== undefined ? obj[h] : '');
  sheet.appendRow(row);
}

/** 条件に合う行を更新 */
function _updateRows(sheetName, matchFn, updateFn) {
  const sheet = _sheet(sheetName);
  const data = sheet.getDataRange().getValues();
  if (data.length < 2) return 0;
  const headers = data[0].map(h => String(h).trim());
  let updated = 0;
  for (let i = 1; i < data.length; i++) {
    const obj = {};
    headers.forEach((h, j) => { obj[h] = data[i][j]; });
    if (matchFn(obj)) {
      const newObj = updateFn({ ...obj });
      const newRow = headers.map(h => newObj[h] !== undefined ? newObj[h] : '');
      sheet.getRange(i + 1, 1, 1, newRow.length).setValues([newRow]);
      updated++;
    }
  }
  return updated;
}

/** ユニークID生成 */
function _genId(prefix) {
  const ts = Date.now().toString(36);
  const rand = Math.random().toString(36).substring(2, 6);
  return prefix + '_' + ts + rand;
}

/** 現在日時ISO文字列 */
function _now() {
  return new Date().toISOString();
}

/** サニタイズ: 文字列のみ許可、HTMLタグ除去 */
function _sanitize(val) {
  if (val === null || val === undefined) return '';
  return String(val).replace(/<[^>]*>/g, '').trim();
}

/** 数値変換 */
function _num(val) {
  const n = Number(val);
  return isNaN(n) ? 0 : n;
}

/** ロールチェック（不合格ならエラーオブジェクトを返す） */
function requireRole(allowed, actual) {
  const arr = Array.isArray(allowed) ? allowed : [allowed];
  if (arr.includes(actual)) return null; // OKの場合nullを返す
  return { success: false, error: '権限がありません', code: 'FORBIDDEN' };
}

// ═══════════════════════════════════════════════════════════════
//  認証・セッション
// ═══════════════════════════════════════════════════════════════

function _sha256(text) {
  const raw = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, text, Utilities.Charset.UTF_8);
  return raw.map(b => ('0' + ((b + 256) % 256).toString(16)).slice(-2)).join('');
}

function doLogin(params) {
  const loginId = _sanitize(params.loginId);
  const password = _sanitize(params.password);
  if (!loginId || !password) return { success: false, error: 'IDとパスワードを入力してください' };

  const users = _readAll(SH.users);
  const user = users.find(u => String(u.login_id) === loginId);
  if (!user) return { success: false, error: 'IDまたはパスワードが違います' };

  // パスワード検証
  const hash = _sha256(String(user.salt) + password);
  if (hash !== String(user.password_hash)) return { success: false, error: 'IDまたはパスワードが違います' };

  // セッション作成
  const token = Utilities.getUuid();
  const expires = new Date(Date.now() + SESSION_TTL_HOURS * 3600000).toISOString();
  _appendRow(SH.sessions, { token, user_id: user.user_id, expires, created_at: _now() });

  // ユーザー情報（パスワード以外）
  const groups = _readAll(SH.groups);
  const group = groups.find(g => g.group_id === user.group_id);
  return {
    success: true,
    token,
    user: {
      user_id: user.user_id,
      name: user.name,
      role: user.role,
      group_id: user.group_id,
      group_name: group ? group.name : '',
      is_repeater: user.is_repeater === true || user.is_repeater === 'TRUE',
      reinvest_balance: _num(user.reinvest_balance),
      bank_name: user.bank_name || '',
      bank_branch: user.bank_branch || '',
      bank_type: user.bank_type || '',
      bank_number: user.bank_number || '',
      bank_holder: user.bank_holder || '',
    }
  };
}

function doLogout(token) {
  _updateRows(SH.sessions, s => s.token === token, s => { s.expires = '1970-01-01T00:00:00Z'; return s; });
  return { success: true };
}

function validateSession(token) {
  if (!token) return null;
  const sessions = _readAll(SH.sessions);
  const session = sessions.find(s => String(s.token) === String(token));
  if (!session) return null;

  const expires = new Date(session.expires);
  if (expires < new Date()) return null;

  const users = _readAll(SH.users);
  const user = users.find(u => u.user_id === session.user_id);
  if (!user) return null;

  return {
    userId: user.user_id,
    role: user.role,
    groupId: user.group_id || '',
  };
}

function getMe(userId) {
  const users = _readAll(SH.users);
  const user = users.find(u => u.user_id === userId);
  if (!user) return { success: false, error: 'ユーザーが見つかりません' };
  const groups = _readAll(SH.groups);
  const group = groups.find(g => g.group_id === user.group_id);
  return {
    success: true,
    user: {
      user_id: user.user_id,
      name: user.name,
      email: user.email || '',
      role: user.role,
      group_id: user.group_id,
      group_name: group ? group.name : '',
      is_repeater: user.is_repeater === true || user.is_repeater === 'TRUE',
      reinvest_balance: _num(user.reinvest_balance),
      bank_name: user.bank_name || '',
      bank_branch: user.bank_branch || '',
      bank_type: user.bank_type || '',
      bank_number: user.bank_number || '',
      bank_holder: user.bank_holder || '',
    }
  };
}

function updateProfile(params, userId) {
  const fields = ['email', 'bank_name', 'bank_branch', 'bank_type', 'bank_number', 'bank_holder'];
  const updated = _updateRows(SH.users, u => u.user_id === userId, u => {
    fields.forEach(f => { if (params[f] !== undefined) u[f] = _sanitize(params[f]); });
    return u;
  });
  if (updated === 0) return { success: false, error: '更新に失敗しました' };
  return getMe(userId);
}

// ═══════════════════════════════════════════════════════════════
//  商品
// ═══════════════════════════════════════════════════════════════

function getProducts(role, groupId) {
  const products = _readAll(SH.products);
  const groupPrices = _readAll(SH.group_prices);

  const result = products.map(p => {
    const gp = groupPrices.find(g => g.product_id === p.product_id && g.group_id === groupId);
    return {
      product_id: p.product_id,
      name: p.name,
      buy_price: _num(p.buy_price),
      base_sell_price: _num(p.sell_price),
      total_qty: _num(p.total_qty),
      remaining_qty: _num(p.remaining_qty),
      deadline: p.deadline,
      status: p.status,
      sell_price: gp ? _num(gp.sell_price) : _num(p.sell_price),
      profit_rate: gp ? _num(gp.profit_rate) : null,
      created_at: p.created_at,
    };
  });
  return result;
}

function getProduct(productId, role, groupId) {
  const products = _readAll(SH.products);
  const p = products.find(x => x.product_id === productId);
  if (!p) return { success: false, error: '商品が見つかりません' };

  const gp = _readAll(SH.group_prices).find(g => g.product_id === productId && g.group_id === groupId);
  return {
    ...p,
    buy_price: _num(p.buy_price),
    base_sell_price: _num(p.sell_price),
    sell_price: gp ? _num(gp.sell_price) : _num(p.sell_price),
    total_qty: _num(p.total_qty),
    remaining_qty: _num(p.remaining_qty),
    profit_rate: gp ? _num(gp.profit_rate) : null,
  };
}

function createProduct(params) {
  const id = _genId('P');
  const buyPrice = _num(params.buy_price);
  const sellPrice = _num(params.sell_price) || buyPrice;
  const product = {
    product_id: id,
    name: _sanitize(params.name),
    buy_price: buyPrice,
    sell_price: sellPrice,
    total_qty: _num(params.total_qty),
    remaining_qty: _num(params.total_qty),
    deadline: _sanitize(params.deadline),
    status: 'draft',
    created_at: _now(),
    updated_at: _now(),
  };
  _appendRow(SH.products, product);

  // 全グループに管理者の売単価を初期値として設定
  const groups = _readAll(SH.groups);
  const profitRate = buyPrice > 0 ? Math.round((sellPrice - buyPrice) / buyPrice * 1000) / 10 : 0;
  groups.forEach(g => {
    _appendRow(SH.group_prices, {
      product_id: id,
      group_id: g.group_id,
      sell_price: sellPrice,
      profit_rate: profitRate,
      updated_at: _now(),
    });
  });

  return { success: true, product };
}

function updateProduct(params) {
  const updated = _updateRows(SH.products, p => p.product_id === params.productId, p => {
    if (params.name !== undefined) p.name = _sanitize(params.name);
    if (params.sell_price !== undefined) p.sell_price = _num(params.sell_price);
    if (params.buy_price !== undefined) p.buy_price = _num(params.buy_price);
    if (params.status !== undefined) p.status = _sanitize(params.status);
    if (params.deadline !== undefined) p.deadline = _sanitize(params.deadline);
    if (params.remaining_qty !== undefined) p.remaining_qty = _num(params.remaining_qty);
    if (params.total_qty !== undefined) p.total_qty = _num(params.total_qty);
    p.updated_at = _now();
    return p;
  });
  return updated > 0 ? { success: true } : { success: false, error: '商品が見つかりません' };
}

// ═══════════════════════════════════════════════════════════════
//  グループ価格
// ═══════════════════════════════════════════════════════════════

function getGroupPrices(productId, role, groupId) {
  const prices = _readAll(SH.group_prices).filter(g => g.product_id === productId);
  if (role === 'leader') return prices.filter(g => g.group_id === groupId);
  return prices;
}

function updateGroupPrice(params, role, groupId) {
  if (role === 'leader' && params.groupId !== groupId) {
    return { success: false, error: '他グループの価格は変更できません' };
  }
  const product = _readAll(SH.products).find(p => p.product_id === params.productId);
  if (!product) return { success: false, error: '商品が見つかりません' };

  const sellPrice = _num(params.sell_price);
  const buyPrice = _num(product.buy_price);
  const profitRate = buyPrice > 0 ? Math.round((sellPrice - buyPrice) / buyPrice * 1000) / 10 : 0;

  const updated = _updateRows(SH.group_prices,
    g => g.product_id === params.productId && g.group_id === params.groupId,
    g => { g.sell_price = sellPrice; g.profit_rate = profitRate; g.updated_at = _now(); return g; }
  );

  if (updated === 0) {
    _appendRow(SH.group_prices, {
      product_id: params.productId,
      group_id: params.groupId,
      sell_price: sellPrice,
      profit_rate: profitRate,
      updated_at: _now(),
    });
  }
  return { success: true };
}

// ═══════════════════════════════════════════════════════════════
//  注文
// ═══════════════════════════════════════════════════════════════

function getOrders(role, userId, groupId) {
  let orders = _readAll(SH.orders);
  if (role === 'user') orders = orders.filter(o => o.user_id === userId);
  else if (role === 'leader') {
    const groupUsers = _readAll(SH.users).filter(u => u.group_id === groupId).map(u => u.user_id);
    orders = orders.filter(o => groupUsers.includes(o.user_id));
  }
  // ユーザー名・商品名をJOIN
  const users = _readAll(SH.users);
  const products = _readAll(SH.products);
  return orders.map(o => ({
    ...o,
    total: _num(o.total),
    qty: _num(o.qty),
    unit_price: _num(o.unit_price),
    balance_used: _num(o.balance_used),
    transfer_amount: _num(o.transfer_amount),
    user_name: (users.find(u => u.user_id === o.user_id) || {}).name || '',
    product_name: (products.find(p => p.product_id === o.product_id) || {}).name || '',
    group_id: (users.find(u => u.user_id === o.user_id) || {}).group_id || '',
  }));
}

function createOrder(params, userId, groupId) {
  const products = _readAll(SH.products);
  const p = products.find(x => x.product_id === params.productId);
  if (!p) return { success: false, error: '商品が見つかりません' };

  const qty = _num(params.qty);
  if (qty <= 0) return { success: false, error: '数量を入力してください' };
  if (_num(p.remaining_qty) < qty) return { success: false, error: '在庫が不足しています（残り: ' + p.remaining_qty + '個）' };

  const gp = _readAll(SH.group_prices).find(g => g.product_id === params.productId && g.group_id === groupId);
  if (!gp) return { success: false, error: 'グループ価格が設定されていません' };

  const unitPrice = _num(gp.sell_price);
  const total = unitPrice * qty;

  // 残高充当
  const user = _readAll(SH.users).find(u => u.user_id === userId);
  const balance = _num(user.reinvest_balance);
  const balanceUsed = Math.min(Math.max(_num(params.balanceUsed), 0), Math.min(balance, total));
  const transferAmount = total - balanceUsed;

  const orderId = _genId('ORD');
  const now = _now();
  const deadline = transferAmount > 0 ? new Date(Date.now() + PAYMENT_DEADLINE_DAYS * 86400000).toISOString() : '';

  const order = {
    order_id: orderId,
    user_id: userId,
    product_id: params.productId,
    qty: qty,
    unit_price: unitPrice,
    total: total,
    balance_used: balanceUsed,
    transfer_amount: transferAmount,
    status: transferAmount > 0 ? 'pending_payment' : 'confirmed',
    receipt_url: '',
    payment_deadline: deadline,
    created_at: now,
    updated_at: now,
  };

  _appendRow(SH.orders, order);

  // 在庫減算
  _updateRows(SH.products, x => x.product_id === params.productId, x => {
    x.remaining_qty = _num(x.remaining_qty) - qty;
    x.updated_at = now;
    return x;
  });

  // 残高減算
  if (balanceUsed > 0) {
    _updateRows(SH.users, u => u.user_id === userId, u => {
      u.reinvest_balance = _num(u.reinvest_balance) - balanceUsed;
      return u;
    });
  }

  return { success: true, order };
}

function updateOrder(params) {
  const updated = _updateRows(SH.orders, o => o.order_id === params.orderId, o => {
    if (params.status) o.status = _sanitize(params.status);
    if (params.receipt_url) o.receipt_url = _sanitize(params.receipt_url);
    o.updated_at = _now();
    return o;
  });
  return updated > 0 ? { success: true } : { success: false, error: '注文が見つかりません' };
}

// ═══════════════════════════════════════════════════════════════
//  お戻し
// ═══════════════════════════════════════════════════════════════

function getReturns(role, userId, groupId) {
  let returns = _readAll(SH.returns);
  if (role === 'user') returns = returns.filter(r => r.user_id === userId);
  else if (role === 'leader') {
    const groupUsers = _readAll(SH.users).filter(u => u.group_id === groupId).map(u => u.user_id);
    returns = returns.filter(r => groupUsers.includes(r.user_id));
  }
  const users = _readAll(SH.users);
  const products = _readAll(SH.products);
  const orders = _readAll(SH.orders);
  return returns.map(r => {
    const order = orders.find(o => o.order_id === r.order_id);
    return {
      ...r,
      return_amount: _num(r.return_amount),
      keep_amount: _num(r.keep_amount),
      total_amount: _num(r.total_amount),
      user_name: (users.find(u => u.user_id === r.user_id) || {}).name || '',
      product_name: order ? (products.find(p => p.product_id === order.product_id) || {}).name || '' : '',
    };
  });
}

function createReturn(params, userId) {
  const orders = _readAll(SH.orders);
  const order = orders.find(o => o.order_id === params.orderId && o.user_id === userId && o.status === 'confirmed');
  if (!order) return { success: false, error: 'お戻し対象の注文が見つかりません' };

  // 既存お戻しチェック
  const existing = _readAll(SH.returns).find(r => r.order_id === params.orderId);
  if (existing) return { success: false, error: 'この注文は既にお戻し申請済みです' };

  const action = params.return_action === 'partial' ? 'partial' : 'full';
  const orderTotal = _num(order.total);
  const product = _readAll(SH.products).find(p => p.product_id === order.product_id);
  const buyPrice = product ? _num(product.buy_price) : 0;
  const profitRate = buyPrice > 0 ? (_num(order.unit_price) - buyPrice) / buyPrice : 0.35;
  const profit = Math.round(orderTotal * profitRate);
  const totalAmount = orderTotal + profit; // 元本+利益

  let returnAmount, keepAmount;
  if (action === 'full') {
    returnAmount = totalAmount;
    keepAmount = 0;
  } else {
    returnAmount = Math.max(1, Math.min(_num(params.returnAmount), totalAmount));
    keepAmount = totalAmount - returnAmount;
  }

  const returnId = _genId('RET');
  const now = _now();
  const ret = {
    return_id: returnId,
    order_id: params.orderId,
    user_id: userId,
    action: action,
    total_amount: totalAmount,
    return_amount: returnAmount,
    keep_amount: keepAmount,
    method: params.method === 'cash' ? 'cash' : 'transfer',
    desired_date: _sanitize(params.desiredDate || ''),
    status: 'unprocessed',
    created_at: now,
    processed_at: '',
    processed_by: '',
  };
  _appendRow(SH.returns, ret);

  // 運用継続分を残高に加算
  if (keepAmount > 0) {
    _updateRows(SH.users, u => u.user_id === userId, u => {
      u.reinvest_balance = _num(u.reinvest_balance) + keepAmount;
      return u;
    });
  }

  return { success: true, returnData: ret };
}

function updateReturn(params, processedBy) {
  const updated = _updateRows(SH.returns, r => r.return_id === params.returnId, r => {
    if (params.status) r.status = _sanitize(params.status);
    r.processed_at = _now();
    r.processed_by = processedBy;
    return r;
  });
  return updated > 0 ? { success: true } : { success: false, error: 'お戻しが見つかりません' };
}

// ═══════════════════════════════════════════════════════════════
//  メッセージ
// ═══════════════════════════════════════════════════════════════

function getThreads(role, userId, groupId) {
  let threads = _readAll(SH.threads);
  if (role === 'user') {
    threads = threads.filter(t => String(t.participants).includes(userId));
  } else if (role === 'leader') {
    const groupUsers = _readAll(SH.users).filter(u => u.group_id === groupId).map(u => u.user_id);
    threads = threads.filter(t => groupUsers.some(uid => String(t.participants).includes(uid)));
  }
  const messages = _readAll(SH.messages);
  return threads.map(t => {
    const threadMsgs = messages.filter(m => m.thread_id === t.thread_id);
    const last = threadMsgs.sort((a, b) => String(b.created_at).localeCompare(String(a.created_at)))[0];
    return {
      ...t,
      last_message: last ? last.text : '',
      last_at: last ? last.created_at : t.created_at,
      unread: 0,
    };
  }).sort((a, b) => String(b.last_at).localeCompare(String(a.last_at)));
}

function getMessages(threadId, userId) {
  const thread = _readAll(SH.threads).find(t => t.thread_id === threadId);
  if (!thread) return { success: false, error: 'スレッドが見つかりません' };
  const messages = _readAll(SH.messages).filter(m => m.thread_id === threadId);
  const users = _readAll(SH.users);
  return messages.map(m => ({
    ...m,
    sender_name: (users.find(u => u.user_id === m.sender_id) || {}).name || '不明',
    is_mine: m.sender_id === userId,
  })).sort((a, b) => String(a.created_at).localeCompare(String(b.created_at)));
}

function sendMessage(params, userId, role) {
  const threadId = _sanitize(params.threadId);
  const text = _sanitize(params.text);
  if (!text) return { success: false, error: 'メッセージを入力してください' };

  const msgId = _genId('MSG');
  _appendRow(SH.messages, {
    message_id: msgId,
    thread_id: threadId,
    sender_id: userId,
    text: text,
    created_at: _now(),
  });

  // スレッドのupdated_atを更新
  _updateRows(SH.threads, t => t.thread_id === threadId, t => { t.updated_at = _now(); return t; });

  return { success: true, messageId: msgId };
}

// ═══════════════════════════════════════════════════════════════
//  ダッシュボード・ユーザー・グループ・日程
// ═══════════════════════════════════════════════════════════════

function getDashboard() {
  const orders = _readAll(SH.orders);
  const returns = _readAll(SH.returns);
  const products = _readAll(SH.products);
  const users = _readAll(SH.users).filter(u => u.role === 'user');

  const confirmed = orders.filter(o => o.status === 'confirmed');
  const totalSales = confirmed.reduce((s, o) => s + _num(o.total), 0);
  const pendingReturns = returns.filter(r => ['unprocessed', 'applied'].includes(r.status));

  return {
    success: true,
    dashboard: {
      total_users: users.length,
      total_products: products.length,
      active_products: products.filter(p => p.status === 'active').length,
      total_orders: orders.length,
      confirmed_orders: confirmed.length,
      pending_orders: orders.filter(o => ['pending_payment', 'pending_receipt'].includes(o.status)).length,
      total_sales: totalSales,
      pending_returns: pendingReturns.length,
      total_return_amount: pendingReturns.reduce((s, r) => s + _num(r.return_amount), 0),
    }
  };
}

function getUsers(role, groupId) {
  let users = _readAll(SH.users);
  if (role === 'leader') users = users.filter(u => u.group_id === groupId);
  const groups = _readAll(SH.groups);
  return users.map(u => ({
    user_id: u.user_id,
    name: u.name,
    email: u.email,
    group_id: u.group_id,
    group_name: (groups.find(g => g.group_id === u.group_id) || {}).name || '',
    role: u.role,
    is_repeater: u.is_repeater === true || u.is_repeater === 'TRUE',
    reinvest_balance: _num(u.reinvest_balance),
  }));
}

function getGroups() {
  return _readAll(SH.groups);
}

function getSchedule() {
  return _readAll(SH.schedule).map(s => ({
    date: s.date,
    rank: _num(s.rank),
    label: s.label || '',
  }));
}

function updateSchedule(params) {
  // params.schedules: [{date, rank, label}, ...]
  const schedules = params.schedules || [];
  const sheet = _sheet(SH.schedule);
  // 全消し＋再書き込み
  if (sheet.getLastRow() > 1) sheet.deleteRows(2, sheet.getLastRow() - 1);
  schedules.forEach(s => {
    _appendRow(SH.schedule, { date: s.date, rank: _num(s.rank), label: _sanitize(s.label) });
  });
  return { success: true };
}

// ═══════════════════════════════════════════════════════════════
//  ファイルアップロード
// ═══════════════════════════════════════════════════════════════

function uploadReceipt(params, userId) {
  const orderId = _sanitize(params.orderId);
  const fileName = _sanitize(params.fileName) || 'receipt.jpg';
  const base64Data = params.base64Data;
  const mimeType = params.mimeType || 'image/jpeg';

  if (!orderId) return { success: false, error: '注文IDが必要です' };
  if (!base64Data) return { success: false, error: 'ファイルデータがありません' };

  // 注文が自分のものか確認
  const orders = _readAll(SH.orders);
  const order = orders.find(o => o.order_id === orderId && o.user_id === userId);
  if (!order) return { success: false, error: '注文が見つかりません' };

  try {
    // Google Driveに保存
    const blob = Utilities.newBlob(Utilities.base64Decode(base64Data), mimeType, fileName);
    
    // 「出資管理_明細」フォルダを取得or作成
    let folder;
    const folders = DriveApp.getFoldersByName('出資管理_明細');
    if (folders.hasNext()) {
      folder = folders.next();
    } else {
      folder = DriveApp.createFolder('出資管理_明細');
    }

    // ファイル名にユーザーID+注文IDを付与
    const safeName = orderId + '_' + userId + '_' + fileName;
    blob.setName(safeName);
    const file = folder.createFile(blob);
    
    // 誰でも閲覧可能にする
    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    const fileUrl = file.getUrl();

    // 注文を更新
    _updateRows(SH.orders, o => o.order_id === orderId, o => {
      o.receipt_url = fileUrl;
      o.status = 'pending_receipt';
      o.updated_at = _now();
      return o;
    });

    return { success: true, receipt_url: fileUrl };
  } catch (err) {
    Logger.log('Upload error: ' + err.message);
    return { success: false, error: 'ファイルのアップロードに失敗しました' };
  }
}

// ═══════════════════════════════════════════════════════════════
//  ユーザー管理（admin専用）
// ═══════════════════════════════════════════════════════════════

function createUser(params) {
  const loginId = _sanitize(params.login_id);
  const name = _sanitize(params.name);
  const email = _sanitize(params.email);
  const groupId = _sanitize(params.group_id);
  const role = _sanitize(params.role);
  const password = _sanitize(params.password);

  if (!loginId || !name || !password) return { success: false, error: 'ログインID・名前・パスワードは必須です' };
  if (!['admin', 'leader', 'user'].includes(role)) return { success: false, error: 'ロールが不正です' };
  if (role !== 'admin' && !groupId) return { success: false, error: 'グループを選択してください' };

  // 重複チェック
  const existing = _readAll(SH.users);
  if (existing.find(u => String(u.login_id) === loginId)) return { success: false, error: 'このログインIDは既に使われています' };

  const salt = Utilities.getUuid().substring(0, 8);
  const hash = _sha256(salt + password);
  const userId = _genId('U');

  const user = {
    user_id: userId,
    login_id: loginId,
    password_hash: hash,
    salt: salt,
    password_raw: password,
    name: name,
    email: email,
    group_id: role === 'admin' ? '' : groupId,
    role: role,
    is_repeater: params.is_repeater === true || params.is_repeater === 'true' ? 'TRUE' : 'FALSE',
    reinvest_balance: 0,
    created_at: _now(),
  };
  _appendRow(SH.users, user);
  return { success: true, user_id: userId };
}

function updateUser(params) {
  const targetId = _sanitize(params.user_id);
  if (!targetId) return { success: false, error: 'user_idが必要です' };

  // ログインID重複チェック
  if (params.login_id) {
    const all = _readAll(SH.users);
    const dup = all.find(u => String(u.login_id) === _sanitize(params.login_id) && u.user_id !== targetId);
    if (dup) return { success: false, error: 'このログインIDは既に使われています' };
  }

  const updated = _updateRows(SH.users, u => u.user_id === targetId, u => {
    if (params.name !== undefined) u.name = _sanitize(params.name);
    if (params.email !== undefined) u.email = _sanitize(params.email);
    if (params.login_id !== undefined) u.login_id = _sanitize(params.login_id);
    if (params.group_id !== undefined) u.group_id = _sanitize(params.group_id);
    if (params.role !== undefined) u.role = _sanitize(params.role);
    if (params.is_repeater !== undefined) u.is_repeater = (params.is_repeater === true || params.is_repeater === 'true') ? 'TRUE' : 'FALSE';
    if (params.reinvest_balance !== undefined) u.reinvest_balance = _num(params.reinvest_balance);
    return u;
  });
  return updated > 0 ? { success: true } : { success: false, error: 'ユーザーが見つかりません' };
}

function resetPassword(params) {
  const targetId = _sanitize(params.user_id);
  const newPassword = _sanitize(params.new_password);
  if (!targetId || !newPassword) return { success: false, error: 'user_idとnew_passwordが必要です' };
  if (newPassword.length < 4) return { success: false, error: 'パスワードは4文字以上にしてください' };

  const salt = Utilities.getUuid().substring(0, 8);
  const hash = _sha256(salt + newPassword);

  const updated = _updateRows(SH.users, u => u.user_id === targetId, u => {
    u.password_hash = hash;
    u.salt = salt;
    u.password_raw = newPassword;
    return u;
  });
  return updated > 0 ? { success: true } : { success: false, error: 'ユーザーが見つかりません' };
}

function deleteUser(params) {
  const targetId = _sanitize(params.user_id);
  if (!targetId) return { success: false, error: 'user_idが必要です' };

  // 管理者自身は削除不可
  const users = _readAll(SH.users);
  const target = users.find(u => u.user_id === targetId);
  if (!target) return { success: false, error: 'ユーザーが見つかりません' };
  if (target.role === 'admin') {
    const adminCount = users.filter(u => u.role === 'admin').length;
    if (adminCount <= 1) return { success: false, error: '最後の管理者は削除できません' };
  }

  // 行を削除
  const sheet = _sheet(SH.users);
  const data = sheet.getDataRange().getValues();
  const headers = data[0].map(h => String(h).trim());
  const idCol = headers.indexOf('user_id');
  for (let i = data.length - 1; i >= 1; i--) {
    if (String(data[i][idCol]) === targetId) {
      sheet.deleteRow(i + 1);
      return { success: true };
    }
  }
  return { success: false, error: 'ユーザーが見つかりません' };
}

// ═══════════════════════════════════════════════════════════════
//  初期セットアップ用関数（1回だけ実行）
// ═══════════════════════════════════════════════════════════════

/**
 * ★ 初回のみ手動実行: Apps Script エディタでこの関数を選択→実行
 *   管理者アカウントのパスワードハッシュを生成してシートに書き込みます
 */
function setupInitialAdmin() {
  const password = 'admin123'; // ★ 初期パスワード
  const salt = Utilities.getUuid().substring(0, 8);
  const hash = _sha256(salt + password);

  // usersシートのadmin行に直接書き込み
  const updated = _updateRows(SH.users, u => String(u.login_id) === 'admin', u => {
    u.password_hash = hash;
    u.salt = salt;
    u.password_raw = password;
    return u;
  });

  if (updated > 0) {
    Logger.log('=== 初期管理者セットアップ完了 ===');
    Logger.log('login_id: admin / password: ' + password);
    Logger.log('usersシートに直接書き込みました');
  } else {
    Logger.log('=== adminユーザーが見つかりません ===');
    Logger.log('salt: ' + salt);
    Logger.log('password_hash: ' + hash);
    Logger.log('password_raw: ' + password);
    Logger.log('usersシートにadmin行を追加してからやり直してください');
  }
}

/**
 * ★ usersシートにpassword_raw列を追加するヘルパー
 *   既にある場合はスキップ
 */
function addPasswordRawColumn() {
  const sheet = _sheet(SH.users);
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(h => String(h).trim());
  
  if (headers.includes('password_raw')) {
    Logger.log('password_raw列は既に存在します');
    return;
  }

  // salt列の右隣に挿入
  const saltIdx = headers.indexOf('salt');
  const insertCol = saltIdx >= 0 ? saltIdx + 2 : headers.length + 1;
  sheet.insertColumnAfter(insertCol - 1);
  sheet.getRange(1, insertCol).setValue('password_raw').setFontWeight('bold').setBackground('#E8F0FE');
  Logger.log('password_raw列を追加しました（' + insertCol + '列目）');
}

/**
 * ★ productsシートにsell_price列を追加するヘルパー
 *   既にある場合はスキップ
 */
function addSellPriceColumn() {
  const sheet = _sheet(SH.products);
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(h => String(h).trim());
  
  if (headers.includes('sell_price')) {
    Logger.log('sell_price列は既に存在します');
    return;
  }

  // buy_price列の右隣に挿入
  const buyIdx = headers.indexOf('buy_price');
  const insertCol = buyIdx >= 0 ? buyIdx + 2 : headers.length + 1;
  sheet.insertColumnAfter(insertCol - 1);
  sheet.getRange(1, insertCol).setValue('sell_price').setFontWeight('bold').setBackground('#E8F0FE');
  Logger.log('sell_price列を追加しました（' + insertCol + '列目）');
}

/**
 * ★ usersシートに銀行口座列を追加するヘルパー
 */
function addBankColumns() {
  const sheet = _sheet(SH.users);
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(h => String(h).trim());
  const cols = ['bank_name', 'bank_branch', 'bank_type', 'bank_number', 'bank_holder'];
  let added = 0;
  cols.forEach(col => {
    if (!headers.includes(col)) {
      const nextCol = sheet.getLastColumn() + 1;
      sheet.getRange(1, nextCol).setValue(col).setFontWeight('bold').setBackground('#E8F0FE');
      added++;
    }
  });
  Logger.log(added > 0 ? added + '個の銀行口座列を追加しました' : '銀行口座列は既に存在します');
}

/**
 * ★ ユーザー追加時に実行: パスワードハッシュ生成用
 */
function generatePasswordHash() {
  const password = 'user123'; // ★ 変更して実行
  const salt = Utilities.getUuid().substring(0, 8);
  const hash = _sha256(salt + password);

  Logger.log('salt: ' + salt);
  Logger.log('password_hash: ' + hash);
  Logger.log('password_raw: ' + password);
}
